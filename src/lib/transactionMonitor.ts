/**
 * Real-time Transaction Monitoring System for Celora V2
 * Advanced monitoring with:
 * - Real-time transaction analysis
 * - ML-based fraud detection
 * - Behavioral pattern analysis
 * - Risk scoring and alerts
 * - AML transaction monitoring
 * - Suspicious activity reporting (SAR)
 * - Geographic and velocity checks
 * - Network analysis for money laundering detection
 */

export interface Transaction {
  id: string;
  userId: string;
  type: TransactionType;
  amount: number;
  currency: string;
  timestamp: number;
  status: TransactionStatus;
  sourceAccount?: Account;
  destinationAccount?: Account;
  metadata: TransactionMetadata;
  riskScore?: number;
  flags?: TransactionFlag[];
  monitoringResult?: MonitoringResult;
}

export type TransactionType = 
  | 'deposit'
  | 'withdrawal' 
  | 'transfer'
  | 'trade'
  | 'payment'
  | 'refund'
  | 'fee'
  | 'reward'
  | 'conversion';

export type TransactionStatus = 
  | 'pending'
  | 'processing'
  | 'completed'
  | 'failed'
  | 'blocked'
  | 'under_review'
  | 'cancelled';

export interface Account {
  id: string;
  type: 'internal' | 'external' | 'crypto' | 'bank' | 'card';
  identifier: string; // Account number, address, etc.
  provider?: string;
  country?: string;
  verified: boolean;
}

export interface TransactionMetadata {
  ipAddress?: string;
  deviceId?: string;
  userAgent?: string;
  location?: GeolocationData;
  sessionId?: string;
  channel: 'web' | 'mobile' | 'api' | 'admin';
  description?: string;
  reference?: string;
  merchantInfo?: {
    name: string;
    category: string;
    country: string;
  };
}

export interface GeolocationData {
  country: string;
  region: string;
  city: string;
  coordinates?: [number, number];
  timezone: string;
  isVPN?: boolean;
  isTor?: boolean;
  isProxy?: boolean;
}

export interface TransactionFlag {
  id: string;
  type: FlagType;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  rule: string;
  createdAt: number;
  autoGenerated: boolean;
}

export type FlagType = 
  | 'unusual_amount'
  | 'unusual_frequency'
  | 'unusual_location'
  | 'unusual_time'
  | 'velocity_exceeded'
  | 'round_amount'
  | 'structured_transaction'
  | 'high_risk_country'
  | 'sanctions_hit'
  | 'pep_transaction'
  | 'cash_intensive_business'
  | 'smurfing_pattern'
  | 'layering_detected'
  | 'integration_suspicion';

export interface MonitoringResult {
  riskScore: number; // 0-100
  decision: 'allow' | 'block' | 'review' | 'delayed_review';
  confidence: number; // 0-100
  factors: RiskFactor[];
  mlScore?: number;
  rulesTriggered: string[];
  processingTime: number;
}

export interface RiskFactor {
  category: 'amount' | 'frequency' | 'location' | 'behavior' | 'network' | 'external';
  description: string;
  weight: number;
  score: number;
}

export interface UserBehaviorProfile {
  userId: string;
  created: number;
  lastUpdated: number;
  patterns: {
    typicalAmounts: AmountPattern;
    typicalFrequency: FrequencyPattern;
    typicalLocations: LocationPattern;
    typicalTimes: TimePattern;
    preferredChannels: string[];
    typicalCounterparties: string[];
  };
  statistics: {
    totalTransactions: number;
    totalVolume: number;
    averageAmount: number;
    medianAmount: number;
    maxAmount: number;
    accountAge: number;
    velocityMetrics: VelocityMetrics;
  };
  riskIndicators: {
    suspiciousActivityCount: number;
    failedTransactionRate: number;
    locationVariability: number;
    timeVariability: number;
    networkComplexity: number;
  };
}

export interface AmountPattern {
  ranges: Array<{ min: number; max: number; frequency: number }>;
  averageAmount: number;
  standardDeviation: number;
  outlierThreshold: number;
}

export interface FrequencyPattern {
  dailyAverage: number;
  weeklyAverage: number;
  monthlyAverage: number;
  peakHours: number[];
  peakDays: number[];
}

export interface LocationPattern {
  primaryCountries: string[];
  primaryCities: string[];
  travelPattern: Array<{ from: string; to: string; frequency: number }>;
  suspiciousLocations: string[];
}

export interface TimePattern {
  activeHours: number[]; // Hours of day
  activeDays: number[]; // Days of week
  timezone: string;
  nightTimeActivity: number; // Percentage
}

export interface VelocityMetrics {
  last1Hour: { count: number; amount: number };
  last24Hours: { count: number; amount: number };
  last7Days: { count: number; amount: number };
  last30Days: { count: number; amount: number };
}

export interface MonitoringRule {
  id: string;
  name: string;
  description: string;
  category: 'amount' | 'frequency' | 'location' | 'behavior' | 'aml';
  enabled: boolean;
  severity: 'low' | 'medium' | 'high' | 'critical';
  conditions: RuleCondition[];
  actions: RuleAction[];
  weight: number; // For risk scoring
}

export interface RuleCondition {
  type: 'amount' | 'frequency' | 'location' | 'time' | 'user_attribute' | 'external_data';
  operator: '>' | '<' | '=' | '!=' | 'in' | 'not_in' | 'contains' | 'regex';
  value: any;
  timeframe?: string; // e.g., '1h', '24h', '7d'
}

export interface RuleAction {
  type: 'flag' | 'block' | 'review' | 'alert' | 'log';
  parameters?: Record<string, any>;
}

export interface SuspiciousActivityReport {
  id: string;
  userId: string;
  createdAt: number;
  status: 'draft' | 'filed' | 'rejected';
  type: 'suspicious_transaction' | 'suspicious_activity' | 'compliance_violation';
  description: string;
  transactions: string[]; // Transaction IDs
  flags: TransactionFlag[];
  investigator?: string;
  filedAt?: number;
  reportData: {
    totalAmount: number;
    timeframe: { start: number; end: number };
    involvedAccounts: string[];
    suspicionReasons: string[];
    supportingDocuments?: string[];
  };
}

class TransactionMonitor {
  private static instance: TransactionMonitor;
  private userProfiles: Map<string, UserBehaviorProfile> = new Map();
  private transactions: Map<string, Transaction> = new Map();
  private suspiciousReports: Map<string, SuspiciousActivityReport> = new Map();
  private activeMonitoringRules: MonitoringRule[] = [];

  // Default monitoring rules
  private defaultRules: MonitoringRule[] = [
    {
      id: 'high_amount_threshold',
      name: 'High Amount Transaction',
      description: 'Transaction amount exceeds typical user behavior by significant margin',
      category: 'amount',
      enabled: true,
      severity: 'high',
      weight: 25,
      conditions: [
        { type: 'amount', operator: '>', value: 10000 }
      ],
      actions: [
        { type: 'flag', parameters: { flagType: 'unusual_amount' } },
        { type: 'review' }
      ]
    },
    {
      id: 'rapid_succession',
      name: 'Rapid Succession Transactions',
      description: 'Multiple transactions in short time period',
      category: 'frequency',
      enabled: true,
      severity: 'medium',
      weight: 20,
      conditions: [
        { type: 'frequency', operator: '>', value: 5, timeframe: '1h' }
      ],
      actions: [
        { type: 'flag', parameters: { flagType: 'unusual_frequency' } },
        { type: 'alert' }
      ]
    },
    {
      id: 'unusual_location',
      name: 'Unusual Geographic Location',
      description: 'Transaction from location inconsistent with user profile',
      category: 'location',
      enabled: true,
      severity: 'medium',
      weight: 15,
      conditions: [
        { type: 'location', operator: 'not_in', value: 'typical_countries' }
      ],
      actions: [
        { type: 'flag', parameters: { flagType: 'unusual_location' } },
        { type: 'log' }
      ]
    },
    {
      id: 'round_amount_pattern',
      name: 'Round Amount Pattern',
      description: 'Frequent use of round numbers may indicate structuring',
      category: 'behavior',
      enabled: true,
      severity: 'low',
      weight: 10,
      conditions: [
        { type: 'amount', operator: 'regex', value: '^\\d+000$' }
      ],
      actions: [
        { type: 'flag', parameters: { flagType: 'round_amount' } }
      ]
    },
    {
      id: 'structuring_detection',
      name: 'Potential Structuring',
      description: 'Multiple transactions just below reporting threshold',
      category: 'aml',
      enabled: true,
      severity: 'high',
      weight: 30,
      conditions: [
        { type: 'amount', operator: '>', value: 9000 },
        { type: 'amount', operator: '<', value: 10000 },
        { type: 'frequency', operator: '>', value: 3, timeframe: '24h' }
      ],
      actions: [
        { type: 'flag', parameters: { flagType: 'structured_transaction' } },
        { type: 'review' },
        { type: 'alert' }
      ]
    },
    {
      id: 'high_risk_country',
      name: 'High Risk Country Transaction',
      description: 'Transaction to/from high-risk jurisdiction',
      category: 'location',
      enabled: true,
      severity: 'high',
      weight: 25,
      conditions: [
        { type: 'location', operator: 'in', value: ['AF', 'IR', 'KP', 'SY'] }
      ],
      actions: [
        { type: 'flag', parameters: { flagType: 'high_risk_country' } },
        { type: 'block' }
      ]
    },
    {
      id: 'night_time_activity',
      name: 'Unusual Night Time Activity',
      description: 'Large transactions during unusual hours for user',
      category: 'behavior',
      enabled: true,
      severity: 'low',
      weight: 5,
      conditions: [
        { type: 'time', operator: 'in', value: [0, 1, 2, 3, 4, 5] },
        { type: 'amount', operator: '>', value: 5000 }
      ],
      actions: [
        { type: 'flag', parameters: { flagType: 'unusual_time' } }
      ]
    }
  ];

  private constructor() {
    this.activeMonitoringRules = [...this.defaultRules];
  }

  static getInstance(): TransactionMonitor {
    if (!TransactionMonitor.instance) {
      TransactionMonitor.instance = new TransactionMonitor();
    }
    return TransactionMonitor.instance;
  }

  /**
   * Monitor a transaction in real-time
   */
  async monitorTransaction(transaction: Transaction): Promise<MonitoringResult> {
    const startTime = Date.now();
    
    // Get or create user behavior profile
    const userProfile = await this.getUserBehaviorProfile(transaction.userId);
    
    // Initialize monitoring result
    const result: MonitoringResult = {
      riskScore: 0,
      decision: 'allow',
      confidence: 85,
      factors: [],
      rulesTriggered: [],
      processingTime: 0
    };

    // Update user behavior profile with this transaction
    this.updateUserBehaviorProfile(userProfile, transaction);

    // Apply monitoring rules
    for (const rule of this.activeMonitoringRules) {
      if (!rule.enabled) continue;

      const ruleResult = await this.evaluateRule(rule, transaction, userProfile);
      
      if (ruleResult.triggered) {
        result.rulesTriggered.push(rule.id);
        result.riskScore += rule.weight;
        
        // Add risk factors
        result.factors.push({
          category: rule.category as any,
          description: rule.description,
          weight: rule.weight,
          score: rule.weight
        });

        // Execute rule actions
        await this.executeRuleActions(rule, transaction, ruleResult);
      }
    }

    // Apply ML-based scoring (simulate for now)
    result.mlScore = await this.calculateMLRiskScore(transaction, userProfile);
    result.riskScore += result.mlScore * 0.3; // Weight ML score at 30%

    // Determine final decision
    result.decision = this.determineDecision(result.riskScore, transaction);
    
    // Calculate confidence based on data quality and rule certainty
    result.confidence = this.calculateConfidence(result, userProfile);

    result.processingTime = Date.now() - startTime;

    // Store monitoring result
    transaction.monitoringResult = result;
    transaction.riskScore = result.riskScore;
    this.transactions.set(transaction.id, transaction);

    // Log high-risk transactions
    if (result.riskScore > 70) {
      console.warn('High-risk transaction detected:', {
        transactionId: transaction.id,
        userId: transaction.userId,
        riskScore: result.riskScore,
        decision: result.decision,
        rulesTriggered: result.rulesTriggered
      });
    }

    // Auto-generate SAR for very high risk
    if (result.riskScore > 90 && result.decision === 'block') {
      await this.generateSuspiciousActivityReport(transaction.userId, [transaction.id]);
    }

    return result;
  }

  /**
   * Get or create user behavior profile
   */
  private async getUserBehaviorProfile(userId: string): Promise<UserBehaviorProfile> {
    let profile = this.userProfiles.get(userId);
    
    if (!profile) {
      profile = await this.createInitialUserProfile(userId);
      this.userProfiles.set(userId, profile);
    }
    
    return profile;
  }

  /**
   * Create initial user behavior profile
   */
  private async createInitialUserProfile(userId: string): Promise<UserBehaviorProfile> {
    const now = Date.now();
    
    return {
      userId,
      created: now,
      lastUpdated: now,
      patterns: {
        typicalAmounts: {
          ranges: [],
          averageAmount: 0,
          standardDeviation: 0,
          outlierThreshold: 0
        },
        typicalFrequency: {
          dailyAverage: 0,
          weeklyAverage: 0,
          monthlyAverage: 0,
          peakHours: [],
          peakDays: []
        },
        typicalLocations: {
          primaryCountries: [],
          primaryCities: [],
          travelPattern: [],
          suspiciousLocations: []
        },
        typicalTimes: {
          activeHours: [],
          activeDays: [],
          timezone: 'UTC',
          nightTimeActivity: 0
        },
        preferredChannels: [],
        typicalCounterparties: []
      },
      statistics: {
        totalTransactions: 0,
        totalVolume: 0,
        averageAmount: 0,
        medianAmount: 0,
        maxAmount: 0,
        accountAge: 0,
        velocityMetrics: {
          last1Hour: { count: 0, amount: 0 },
          last24Hours: { count: 0, amount: 0 },
          last7Days: { count: 0, amount: 0 },
          last30Days: { count: 0, amount: 0 }
        }
      },
      riskIndicators: {
        suspiciousActivityCount: 0,
        failedTransactionRate: 0,
        locationVariability: 0,
        timeVariability: 0,
        networkComplexity: 0
      }
    };
  }

  /**
   * Update user behavior profile with new transaction
   */
  private updateUserBehaviorProfile(profile: UserBehaviorProfile, transaction: Transaction): void {
    const now = Date.now();
    
    // Update statistics
    profile.statistics.totalTransactions++;
    profile.statistics.totalVolume += transaction.amount;
    profile.statistics.averageAmount = profile.statistics.totalVolume / profile.statistics.totalTransactions;
    profile.statistics.maxAmount = Math.max(profile.statistics.maxAmount, transaction.amount);

    // Update velocity metrics
    this.updateVelocityMetrics(profile, transaction, now);

    // Update location patterns
    if (transaction.metadata.location) {
      this.updateLocationPatterns(profile, transaction.metadata.location);
    }

    // Update time patterns
    this.updateTimePatterns(profile, transaction.timestamp);

    // Update amount patterns
    this.updateAmountPatterns(profile, transaction.amount);

    // Update channel preferences
    if (!profile.patterns.preferredChannels.includes(transaction.metadata.channel)) {
      profile.patterns.preferredChannels.push(transaction.metadata.channel);
    }

    profile.lastUpdated = now;
  }

  /**
   * Update velocity metrics
   */
  private updateVelocityMetrics(profile: UserBehaviorProfile, transaction: Transaction, now: number): void {
    const metrics = profile.statistics.velocityMetrics;
    
    // 1 hour window
    if (now - transaction.timestamp <= 60 * 60 * 1000) {
      metrics.last1Hour.count++;
      metrics.last1Hour.amount += transaction.amount;
    }
    
    // 24 hours window
    if (now - transaction.timestamp <= 24 * 60 * 60 * 1000) {
      metrics.last24Hours.count++;
      metrics.last24Hours.amount += transaction.amount;
    }
    
    // 7 days window
    if (now - transaction.timestamp <= 7 * 24 * 60 * 60 * 1000) {
      metrics.last7Days.count++;
      metrics.last7Days.amount += transaction.amount;
    }
    
    // 30 days window
    if (now - transaction.timestamp <= 30 * 24 * 60 * 60 * 1000) {
      metrics.last30Days.count++;
      metrics.last30Days.amount += transaction.amount;
    }
  }

  /**
   * Update location patterns
   */
  private updateLocationPatterns(profile: UserBehaviorProfile, location: GeolocationData): void {
    const patterns = profile.patterns.typicalLocations;
    
    // Add to primary countries if not already present
    if (!patterns.primaryCountries.includes(location.country)) {
      patterns.primaryCountries.push(location.country);
    }
    
    // Add to primary cities if not already present
    if (!patterns.primaryCities.includes(location.city)) {
      patterns.primaryCities.push(location.city);
    }
    
    // Check for suspicious indicators
    if (location.isVPN || location.isTor || location.isProxy) {
      const suspiciousLocation = `${location.city}, ${location.country}`;
      if (!patterns.suspiciousLocations.includes(suspiciousLocation)) {
        patterns.suspiciousLocations.push(suspiciousLocation);
      }
    }
  }

  /**
   * Update time patterns
   */
  private updateTimePatterns(profile: UserBehaviorProfile, timestamp: number): void {
    const date = new Date(timestamp);
    const hour = date.getHours();
    const dayOfWeek = date.getDay();
    
    const patterns = profile.patterns.typicalTimes;
    
    // Update active hours
    if (!patterns.activeHours.includes(hour)) {
      patterns.activeHours.push(hour);
    }
    
    // Update active days
    if (!patterns.activeDays.includes(dayOfWeek)) {
      patterns.activeDays.push(dayOfWeek);
    }
    
    // Calculate night time activity percentage
    if (hour >= 23 || hour <= 5) {
      const nightTransactions = profile.statistics.totalTransactions * (patterns.nightTimeActivity / 100) + 1;
      patterns.nightTimeActivity = (nightTransactions / profile.statistics.totalTransactions) * 100;
    }
  }

  /**
   * Update amount patterns
   */
  private updateAmountPatterns(profile: UserBehaviorProfile, amount: number): void {
    const patterns = profile.patterns.typicalAmounts;
    
    // Simple implementation - in production, use more sophisticated statistical analysis
    const amounts = [amount]; // In practice, this would be all historical amounts
    
    patterns.averageAmount = amount; // Simplified
    patterns.standardDeviation = 0; // Would calculate from historical data
    patterns.outlierThreshold = patterns.averageAmount * 3; // 3x average as outlier threshold
  }

  /**
   * Evaluate monitoring rule against transaction
   */
  private async evaluateRule(
    rule: MonitoringRule, 
    transaction: Transaction, 
    userProfile: UserBehaviorProfile
  ): Promise<{ triggered: boolean; details?: any }> {
    
    for (const condition of rule.conditions) {
      const conditionMet = await this.evaluateCondition(condition, transaction, userProfile);
      
      if (!conditionMet) {
        return { triggered: false };
      }
    }
    
    return { triggered: true };
  }

  /**
   * Evaluate individual rule condition
   */
  private async evaluateCondition(
    condition: RuleCondition,
    transaction: Transaction,
    userProfile: UserBehaviorProfile
  ): Promise<boolean> {
    
    switch (condition.type) {
      case 'amount':
        return this.evaluateAmountCondition(condition, transaction.amount);
      
      case 'frequency':
        return this.evaluateFrequencyCondition(condition, transaction, userProfile);
      
      case 'location':
        return this.evaluateLocationCondition(condition, transaction, userProfile);
      
      case 'time':
        return this.evaluateTimeCondition(condition, transaction);
      
      case 'user_attribute':
        return this.evaluateUserAttributeCondition(condition, userProfile);
      
      default:
        return false;
    }
  }

  /**
   * Evaluate amount-based conditions
   */
  private evaluateAmountCondition(condition: RuleCondition, amount: number): boolean {
    switch (condition.operator) {
      case '>':
        return amount > condition.value;
      case '<':
        return amount < condition.value;
      case '=':
        return amount === condition.value;
      case '!=':
        return amount !== condition.value;
      case 'regex':
        return new RegExp(condition.value).test(amount.toString());
      default:
        return false;
    }
  }

  /**
   * Evaluate frequency-based conditions
   */
  private evaluateFrequencyCondition(
    condition: RuleCondition,
    transaction: Transaction,
    userProfile: UserBehaviorProfile
  ): boolean {
    if (!condition.timeframe) return false;
    
    const timeframeMs = this.parseTimeframe(condition.timeframe);
    const now = Date.now();
    const windowStart = now - timeframeMs;
    
    // Count transactions in timeframe (simplified - would query actual transaction history)
    let count = 0;
    
    switch (condition.timeframe) {
      case '1h':
        count = userProfile.statistics.velocityMetrics.last1Hour.count;
        break;
      case '24h':
        count = userProfile.statistics.velocityMetrics.last24Hours.count;
        break;
      case '7d':
        count = userProfile.statistics.velocityMetrics.last7Days.count;
        break;
      case '30d':
        count = userProfile.statistics.velocityMetrics.last30Days.count;
        break;
      default:
        return false;
    }
    
    return this.compareValues(count, condition.operator, condition.value);
  }

  /**
   * Evaluate location-based conditions
   */
  private evaluateLocationCondition(
    condition: RuleCondition,
    transaction: Transaction,
    userProfile: UserBehaviorProfile
  ): boolean {
    const location = transaction.metadata.location;
    if (!location) return false;
    
    switch (condition.value) {
      case 'typical_countries':
        const isTypicalCountry = userProfile.patterns.typicalLocations.primaryCountries.includes(location.country);
        return condition.operator === 'in' ? isTypicalCountry : !isTypicalCountry;
      
      default:
        if (Array.isArray(condition.value)) {
          const inArray = condition.value.includes(location.country);
          return condition.operator === 'in' ? inArray : !inArray;
        }
        return false;
    }
  }

  /**
   * Evaluate time-based conditions
   */
  private evaluateTimeCondition(condition: RuleCondition, transaction: Transaction): boolean {
    const date = new Date(transaction.timestamp);
    const hour = date.getHours();
    
    if (Array.isArray(condition.value)) {
      const inArray = condition.value.includes(hour);
      return condition.operator === 'in' ? inArray : !inArray;
    }
    
    return false;
  }

  /**
   * Evaluate user attribute conditions
   */
  private evaluateUserAttributeCondition(condition: RuleCondition, userProfile: UserBehaviorProfile): boolean {
    // Implementation would depend on specific user attributes being checked
    return false;
  }

  /**
   * Execute rule actions
   */
  private async executeRuleActions(
    rule: MonitoringRule,
    transaction: Transaction,
    ruleResult: { triggered: boolean; details?: any }
  ): Promise<void> {
    
    for (const action of rule.actions) {
      switch (action.type) {
        case 'flag':
          await this.flagTransaction(transaction, rule, action.parameters);
          break;
        
        case 'block':
          transaction.status = 'blocked';
          break;
        
        case 'review':
          transaction.status = 'under_review';
          break;
        
        case 'alert':
          await this.sendAlert(transaction, rule);
          break;
        
        case 'log':
          console.log(`Transaction monitoring rule triggered: ${rule.name}`, {
            transactionId: transaction.id,
            rule: rule.id,
            details: ruleResult.details
          });
          break;
      }
    }
  }

  /**
   * Flag transaction
   */
  private async flagTransaction(
    transaction: Transaction,
    rule: MonitoringRule,
    parameters?: Record<string, any>
  ): Promise<void> {
    if (!transaction.flags) {
      transaction.flags = [];
    }
    
    const flag: TransactionFlag = {
      id: this.generateId(),
      type: parameters?.flagType || 'suspicious_activity',
      severity: rule.severity,
      description: rule.description,
      rule: rule.id,
      createdAt: Date.now(),
      autoGenerated: true
    };
    
    transaction.flags.push(flag);
  }

  /**
   * Send alert for high-risk transaction
   */
  private async sendAlert(transaction: Transaction, rule: MonitoringRule): Promise<void> {
    // In production, send to monitoring dashboard, email, Slack, etc.
    console.warn(`TRANSACTION ALERT: ${rule.name}`, {
      transactionId: transaction.id,
      userId: transaction.userId,
      amount: transaction.amount,
      rule: rule.id,
      timestamp: new Date(transaction.timestamp).toISOString()
    });
  }

  /**
   * Calculate ML-based risk score (simulated)
   */
  private async calculateMLRiskScore(
    transaction: Transaction,
    userProfile: UserBehaviorProfile
  ): Promise<number> {
    // Simulate ML model prediction
    let score = 0;
    
    // Amount anomaly detection
    if (userProfile.patterns.typicalAmounts.averageAmount > 0) {
      const amountRatio = transaction.amount / userProfile.patterns.typicalAmounts.averageAmount;
      if (amountRatio > 5 || amountRatio < 0.1) {
        score += 20;
      }
    }
    
    // Location anomaly
    if (transaction.metadata.location) {
      const isTypicalLocation = userProfile.patterns.typicalLocations.primaryCountries
        .includes(transaction.metadata.location.country);
      if (!isTypicalLocation) {
        score += 15;
      }
      
      if (transaction.metadata.location.isVPN || transaction.metadata.location.isTor) {
        score += 25;
      }
    }
    
    // Time anomaly
    const hour = new Date(transaction.timestamp).getHours();
    if (!userProfile.patterns.typicalTimes.activeHours.includes(hour)) {
      score += 10;
    }
    
    // Velocity anomaly
    if (userProfile.statistics.velocityMetrics.last1Hour.count > 5) {
      score += 30;
    }
    
    return Math.min(score, 100);
  }

  /**
   * Determine final monitoring decision
   */
  private determineDecision(riskScore: number, transaction: Transaction): MonitoringResult['decision'] {
    // Critical risk - immediate block
    if (riskScore >= 90) {
      return 'block';
    }
    
    // High risk - manual review required
    if (riskScore >= 70) {
      return 'review';
    }
    
    // Medium risk - delayed automated review
    if (riskScore >= 40) {
      return 'delayed_review';
    }
    
    // Low risk - allow
    return 'allow';
  }

  /**
   * Calculate confidence score
   */
  private calculateConfidence(result: MonitoringResult, userProfile: UserBehaviorProfile): number {
    let confidence = 85; // Base confidence
    
    // Reduce confidence if user profile is new/sparse
    if (userProfile.statistics.totalTransactions < 10) {
      confidence -= 20;
    }
    
    // Reduce confidence if multiple conflicting indicators
    if (result.factors.length > 5) {
      confidence -= 10;
    }
    
    // Increase confidence if ML and rules agree
    if (result.mlScore && result.riskScore > 50 && result.mlScore > 50) {
      confidence += 10;
    }
    
    return Math.max(Math.min(confidence, 100), 0);
  }

  /**
   * Generate Suspicious Activity Report
   */
  async generateSuspiciousActivityReport(
    userId: string,
    transactionIds: string[],
    investigator?: string
  ): Promise<SuspiciousActivityReport> {
    const transactions = transactionIds.map(id => this.transactions.get(id)).filter(Boolean) as Transaction[];
    
    const report: SuspiciousActivityReport = {
      id: this.generateId(),
      userId,
      createdAt: Date.now(),
      status: 'draft',
      type: 'suspicious_transaction',
      description: 'Automated suspicious activity detection',
      transactions: transactionIds,
      flags: transactions.flatMap(t => t.flags || []),
      investigator,
      reportData: {
        totalAmount: transactions.reduce((sum, t) => sum + t.amount, 0),
        timeframe: {
          start: Math.min(...transactions.map(t => t.timestamp)),
          end: Math.max(...transactions.map(t => t.timestamp))
        },
        involvedAccounts: [...new Set(transactions.flatMap(t => [
          t.sourceAccount?.id,
          t.destinationAccount?.id
        ]).filter(Boolean) as string[])],
        suspicionReasons: [...new Set(transactions.flatMap(t => 
          t.flags?.map(f => f.description) || []
        ))]
      }
    };
    
    this.suspiciousReports.set(report.id, report);
    
    return report;
  }

  /**
   * Helper methods
   */
  private parseTimeframe(timeframe: string): number {
    const match = timeframe.match(/^(\d+)([hdwmy])$/);
    if (!match) return 0;
    
    const value = parseInt(match[1]);
    const unit = match[2];
    
    switch (unit) {
      case 'h': return value * 60 * 60 * 1000;
      case 'd': return value * 24 * 60 * 60 * 1000;
      case 'w': return value * 7 * 24 * 60 * 60 * 1000;
      case 'm': return value * 30 * 24 * 60 * 60 * 1000;
      case 'y': return value * 365 * 24 * 60 * 60 * 1000;
      default: return 0;
    }
  }

  private compareValues(actual: any, operator: string, expected: any): boolean {
    switch (operator) {
      case '>': return actual > expected;
      case '<': return actual < expected;
      case '=': return actual === expected;
      case '!=': return actual !== expected;
      case 'in': return Array.isArray(expected) ? expected.includes(actual) : false;
      case 'not_in': return Array.isArray(expected) ? !expected.includes(actual) : true;
      case 'contains': return String(actual).includes(String(expected));
      case 'regex': return new RegExp(expected).test(String(actual));
      default: return false;
    }
  }

  private generateId(): string {
    return `txm_${Date.now()}_${Math.random().toString(36).substring(7)}`;
  }

  /**
   * Query transactions by criteria
   */
  queryTransactions(criteria: {
    userId?: string;
    riskScoreMin?: number;
    status?: TransactionStatus;
    startTime?: number;
    endTime?: number;
    flagType?: FlagType;
  }): Transaction[] {
    return Array.from(this.transactions.values()).filter(transaction => {
      if (criteria.userId && transaction.userId !== criteria.userId) return false;
      if (criteria.riskScoreMin && (transaction.riskScore || 0) < criteria.riskScoreMin) return false;
      if (criteria.status && transaction.status !== criteria.status) return false;
      if (criteria.startTime && transaction.timestamp < criteria.startTime) return false;
      if (criteria.endTime && transaction.timestamp > criteria.endTime) return false;
      if (criteria.flagType && !transaction.flags?.some(f => f.type === criteria.flagType)) return false;
      
      return true;
    });
  }

  /**
   * Get user behavior profile
   */
  getUserProfile(userId: string): UserBehaviorProfile | undefined {
    return this.userProfiles.get(userId);
  }

  /**
   * Get suspicious activity reports
   */
  getSuspiciousReports(status?: SuspiciousActivityReport['status']): SuspiciousActivityReport[] {
    const reports = Array.from(this.suspiciousReports.values());
    return status ? reports.filter(r => r.status === status) : reports;
  }

  /**
   * Add custom monitoring rule
   */
  addMonitoringRule(rule: MonitoringRule): void {
    this.activeMonitoringRules.push(rule);
  }

  /**
   * Remove monitoring rule
   */
  removeMonitoringRule(ruleId: string): boolean {
    const index = this.activeMonitoringRules.findIndex(r => r.id === ruleId);
    if (index >= 0) {
      this.activeMonitoringRules.splice(index, 1);
      return true;
    }
    return false;
  }
}

// Export singleton instance
export const transactionMonitor = TransactionMonitor.getInstance();
