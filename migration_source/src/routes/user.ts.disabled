import express, { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import Joi from 'joi';
import speakeasy from 'speakeasy';
import { prisma } from '../server';
import { AuthenticatedRequest } from '../middleware/auth';
import { ValidationError, NotFoundError, ConflictError } from '../middleware/errorHandler';
import { asyncHandler } from '../middleware/errorHandler';

const router = express.Router();

// Validation schemas
const updateProfileSchema = Joi.object({
  firstName: Joi.string().allow('').optional(),
  lastName: Joi.string().allow('').optional(),
  phoneNumber: Joi.string().allow('').optional(),
  dateOfBirth: Joi.date().optional(),
  country: Joi.string().allow('').optional(),
  preferredCurrency: Joi.string().valid('USD', 'EUR', 'GBP', 'BTC', 'ETH').optional(),
  theme: Joi.string().valid('light', 'dark').optional(),
  language: Joi.string().valid('en', 'es', 'fr', 'de', 'ja', 'ko', 'zh').optional()
});

const changePasswordSchema = Joi.object({
  currentPassword: Joi.string().required(),
  newPassword: Joi.string().min(8).pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/).required()
    .messages({
      'string.pattern.base': 'Password must contain at least one uppercase letter, one lowercase letter, one number and one special character'
    })
});

const connectWalletSchema = Joi.object({
  walletAddress: Joi.string().required(),
  signature: Joi.string().required(),
  message: Joi.string().required(),
  walletType: Joi.string().valid('METAMASK', 'PHANTOM', 'WALLET_CONNECT', 'COINBASE_WALLET').required()
});

// Get user profile
router.get('/profile', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const user = await prisma.user.findUnique({
    where: { id: req.user!.id },
    select: {
      id: true,
      email: true,
      firstName: true,
      lastName: true,
      phoneNumber: true,
      dateOfBirth: true,
      country: true,
      walletAddress: true,
      walletType: true,
      twoFactorEnabled: true,
      preferredCurrency: true,
      theme: true,
      language: true,
      emailVerified: true,
      lastLogin: true,
      createdAt: true,
      updatedAt: true
    }
  });

  if (!user) {
    throw new NotFoundError('User not found');
  }

  res.json({
    user
  });
}));

// Update user profile
router.put('/profile', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const { error, value } = updateProfileSchema.validate(req.body);
  if (error) {
    throw new ValidationError(error.details[0].message);
  }

  const updatedUser = await prisma.user.update({
    where: { id: req.user!.id },
    data: value,
    select: {
      id: true,
      email: true,
      firstName: true,
      lastName: true,
      phoneNumber: true,
      dateOfBirth: true,
      country: true,
      preferredCurrency: true,
      theme: true,
      language: true,
      updatedAt: true
    }
  });

  res.json({
    message: 'Profile updated successfully',
    user: updatedUser
  });
}));

// Change password
router.put('/password', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const { error, value } = changePasswordSchema.validate(req.body);
  if (error) {
    throw new ValidationError(error.details[0].message);
  }

  const { currentPassword, newPassword } = value;

  const user = await prisma.user.findUnique({
    where: { id: req.user!.id },
    select: { passwordHash: true }
  });

  if (!user || !user.passwordHash) {
    throw new ValidationError('Cannot change password for wallet-only accounts');
  }

  // Verify current password
  const passwordValid = await bcrypt.compare(currentPassword, user.passwordHash);
  if (!passwordValid) {
    throw new ValidationError('Current password is incorrect');
  }

  // Hash new password
  const saltRounds = 12;
  const newPasswordHash = await bcrypt.hash(newPassword, saltRounds);

  await prisma.user.update({
    where: { id: req.user!.id },
    data: { passwordHash: newPasswordHash }
  });

  res.json({
    message: 'Password changed successfully'
  });
}));

// Enable 2FA
router.post('/2fa/enable', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const user = await prisma.user.findUnique({
    where: { id: req.user!.id },
    select: { email: true, twoFactorEnabled: true }
  });

  if (!user) {
    throw new NotFoundError('User not found');
  }

  if (user.twoFactorEnabled) {
    throw new ConflictError('Two-factor authentication is already enabled');
  }

  // Generate secret
  const secret = speakeasy.generateSecret({
    name: `Celora (${user.email})`,
    issuer: 'Celora'
  });

  // Store secret temporarily (in real app, might want to use Redis)
  await prisma.user.update({
    where: { id: req.user!.id },
    data: { twoFactorSecret: secret.base32 }
  });

  res.json({
    message: 'Two-factor authentication setup initiated',
    qrCode: secret.otpauth_url,
    secret: secret.base32,
    manualEntryKey: secret.base32
  });
}));

// Confirm 2FA setup
router.post('/2fa/confirm', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const { token } = req.body;

  if (!token) {
    throw new ValidationError('Two-factor authentication token is required');
  }

  const user = await prisma.user.findUnique({
    where: { id: req.user!.id },
    select: { twoFactorSecret: true, twoFactorEnabled: true }
  });

  if (!user || !user.twoFactorSecret) {
    throw new ValidationError('Two-factor authentication setup not initiated');
  }

  if (user.twoFactorEnabled) {
    throw new ConflictError('Two-factor authentication is already enabled');
  }

  // Verify token
  const verified = speakeasy.totp.verify({
    secret: user.twoFactorSecret,
    encoding: 'base32',
    token: token,
    window: 2
  });

  if (!verified) {
    throw new ValidationError('Invalid two-factor authentication token');
  }

  // Enable 2FA
  await prisma.user.update({
    where: { id: req.user!.id },
    data: { twoFactorEnabled: true }
  });

  res.json({
    message: 'Two-factor authentication enabled successfully'
  });
}));

// Disable 2FA
router.post('/2fa/disable', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const { token } = req.body;

  if (!token) {
    throw new ValidationError('Two-factor authentication token is required');
  }

  const user = await prisma.user.findUnique({
    where: { id: req.user!.id },
    select: { twoFactorSecret: true, twoFactorEnabled: true }
  });

  if (!user || !user.twoFactorEnabled || !user.twoFactorSecret) {
    throw new ValidationError('Two-factor authentication is not enabled');
  }

  // Verify token
  const verified = speakeasy.totp.verify({
    secret: user.twoFactorSecret,
    encoding: 'base32',
    token: token,
    window: 2
  });

  if (!verified) {
    throw new ValidationError('Invalid two-factor authentication token');
  }

  // Disable 2FA
  await prisma.user.update({
    where: { id: req.user!.id },
    data: { 
      twoFactorEnabled: false,
      twoFactorSecret: null
    }
  });

  res.json({
    message: 'Two-factor authentication disabled successfully'
  });
}));

// Connect wallet to existing account
router.post('/wallet/connect', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const { error, value } = connectWalletSchema.validate(req.body);
  if (error) {
    throw new ValidationError(error.details[0].message);
  }

  const { walletAddress, signature, message, walletType } = value;

  // Check if wallet is already connected to another account
  const existingWallet = await prisma.user.findUnique({
    where: { walletAddress: walletAddress.toLowerCase() }
  });

  if (existingWallet && existingWallet.id !== req.user!.id) {
    throw new ConflictError('This wallet is already connected to another account');
  }

  // Verify signature (simplified)
  // In production, implement proper signature verification

  // Update user with wallet info
  const updatedUser = await prisma.user.update({
    where: { id: req.user!.id },
    data: {
      walletAddress: walletAddress.toLowerCase(),
      walletType: walletType as any
    },
    select: {
      id: true,
      email: true,
      walletAddress: true,
      walletType: true
    }
  });

  res.json({
    message: 'Wallet connected successfully',
    user: updatedUser
  });
}));

// Disconnect wallet
router.delete('/wallet/disconnect', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  await prisma.user.update({
    where: { id: req.user!.id },
    data: {
      walletAddress: null,
      walletType: null
    }
  });

  res.json({
    message: 'Wallet disconnected successfully'
  });
}));

// Get user sessions
router.get('/sessions', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const sessions = await prisma.userSession.findMany({
    where: { userId: req.user!.id },
    select: {
      id: true,
      deviceInfo: true,
      ipAddress: true,
      createdAt: true,
      expiresAt: true
    },
    orderBy: { createdAt: 'desc' }
  });

  res.json({
    sessions
  });
}));

// Revoke session
router.delete('/sessions/:sessionId', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const { sessionId } = req.params;

  await prisma.userSession.deleteMany({
    where: {
      id: sessionId,
      userId: req.user!.id
    }
  });

  res.json({
    message: 'Session revoked successfully'
  });
}));

// Revoke all sessions
router.delete('/sessions', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  await prisma.userSession.deleteMany({
    where: { userId: req.user!.id }
  });

  res.json({
    message: 'All sessions revoked successfully'
  });
}));

// Delete account
router.delete('/account', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const { password } = req.body;

  if (password) {
    // Verify password for email accounts
    const user = await prisma.user.findUnique({
      where: { id: req.user!.id },
      select: { passwordHash: true }
    });

    if (user && user.passwordHash) {
      const passwordValid = await bcrypt.compare(password, user.passwordHash);
      if (!passwordValid) {
        throw new ValidationError('Password is incorrect');
      }
    }
  }

  // Delete user (cascade will handle related records)
  await prisma.user.delete({
    where: { id: req.user!.id }
  });

  res.json({
    message: 'Account deleted successfully'
  });
}));

export default router;
